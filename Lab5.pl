use strict;
use warnings;

use utf8;

if (not scalar(@ARGV)) {
    print "no input file\n";
    exit 1;
}

my $logfile = $ARGV[0];
my $limit = $ARGV[1] // 10; # если нет второго аргумента, то использовать число 10

my @items; # список всех извлечённых из лог-файла элементов
my %items_filter; # хеш-таблица с нашими правилами

# die - это оператор аварийного завершения программы с выводом сообщения об ошибке
die "\"${logfile}\" is not a file" if !-f $logfile; # -f это оператор проверки существования файла, который передаётся в качестве аргумента

open(my $fh, '<', $logfile) or die "not found or access denied: \"${logfile}\""; # '<' - это параметр, который говорит, что файл будет открываться для чтения

while(my $line = readline($fh)) { # в цикле считываем построчно файл до тех пор, пока не достигнем EOF
    # =~ оператор применения регулярного выражения, результат записывается в @_, $_, $1, $2, ... $N в зависимости от количества групп (неэкранированных скобок) в правиле
    if ($line =~ /^(\d+\.\d+\.\d+\.\d+)\s+([^\s])+\s+([^\s]+)\s+\[([^\s\]]+)\s+([^\s\]]+)\]\s+"([^"]+)"\s+\d+\s+\d+\s+"([^"]+)"\s+"([^"]+)"/) {
        push @items, { # заполняем "ассоциативный массив", чтобы потом удобней было с ним работать
                "ip" => $1,
                "blank" => $2,
                "user" => $3,
                "datetime" => $4,
                "timezone" => $5,
                "request" => $6,
                "referer" => $7,
                "user-agent" => $8
            };
    }
}

close($fh); # закрываем файл

$items_filter{$$_{'ip'}} = $items_filter{$$_{'ip'}} ? ++$items_filter{$$_{'ip'}} : 1 for (@items); # записываем в хеш таблицу по ключу $$_{'ip'} значение 1, либо если оно уже есть, увеличиваем его на единицу

# reverse [1, 2, 3] выведет 321
# grep - это фильтрация списка, в данном случае правило $_ отбрасывает все элементы с пустым значением
# keys %items_filter созвращает список ключей хеш-таблицы
# sort сортировка с передачей функции сортировки
# <=> оператор сравнения чисел
# "${items_filter{$_}}: ${_}\n" выводит ключ и значение элемента (в нашем случае это IP и количество запросов с него)
# @list[0..9] вернёт первые 10 элементов списка @list. Если элементов в списке меньше 10, то недостающие элементы будут заполнены пустым значением, для его фильтрации применяется фильтрация через grep, что описана выше
print "${items_filter{$_}}: ${_}\n" for grep { $_ } ((reverse sort { $items_filter{$a} <=> $items_filter{$b} } keys %items_filter)[0..$limit - 1]);
